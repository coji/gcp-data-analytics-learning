# Phase 0-02 演習メモ

## 演習1: パーティション分割テーブルの作成

### 実行日時

YYYY-MM-DD HH:MM

### 作成したテーブル

`PROJECT:DATASET.TABLE`

### パーティションフィルタありのスキャン量

```
This query will process X bytes when run.
```

### パーティションフィルタなしのスキャン量

```
This query will process Y bytes when run.
```

### スキャン量の比較

- フィルタあり: X bytes
- フィルタなし: Y bytes
- **削減率**: ((Y-X)/Y) * 100 = Z%

### 学んだこと

-
-

---

## 演習2: IAM権限の確認

### 自分のアカウントのロール

| ロール | 説明 |
|--------|------|
|        |      |

### サービスアカウント一覧

| サービスアカウント | 用途 |
|-----------------|------|
|                 |      |

### データセットのアクセス権限

---

## 課題1: パーティション・クラスタリング設定の理解

### なぜ`date`カラムでパーティショニングしているのか？

回答:

### なぜ`account_id, campaign_id`でクラスタリングしているのか？

回答:

### `partition_expiration_days = 90`の意図は？

回答:

---

## 課題2: 自分のパーティション分割テーブル作成

### 作成したデータセット名

### 作成したテーブル名

### テーブル定義

```sql
-- CREATE TABLE文をここに記録
```

### 挿入したサンプルデータ

```sql
-- INSERT文をここに記録
```

### 確認クエリ

```sql
-- 確認用SELECT文
```

---

## 課題3: スキャン量の比較実験

### 実験用クエリ

#### 1. パーティションフィルタ + クラスタリングキー

```sql
SELECT *
FROM `PROJECT.DATASET.TABLE`
WHERE date = CURRENT_DATE()
  AND account_id = 'xxx';
```

**スキャン量**:

#### 2. パーティションフィルタのみ

```sql
SELECT *
FROM `PROJECT.DATASET.TABLE`
WHERE date = CURRENT_DATE();
```

**スキャン量**:

#### 3. フィルタなし

```sql
SELECT *
FROM `PROJECT.DATASET.TABLE`
LIMIT 100;
```

**スキャン量**:

### 比較結果

| クエリタイプ | スキャン量 | 削減率 |
|------------|----------|--------|
| フィルタなし |          | 0%     |
| パーティションのみ |      | X%     |
| パーティション+クラスタ | | Y%     |

### 考察

---

## 全体を通しての気づき

### パーティショニングについて

### クラスタリングについて

### コスト削減のポイント

### まだ理解が不十分なこと
